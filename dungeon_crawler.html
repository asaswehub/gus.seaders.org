<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dungeon Crawler</title>
<style>
  :root { color-scheme: dark; }
  body { background:#1a1a1a; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; margin:0; text-align:center; }
  h1 { font-weight:600; margin:16px 0 6px; }
  canvas { background:#000; display:block; margin:16px auto 24px; border:2px solid #555; image-rendering: pixelated; image-rendering: crisp-edges; }
  .hint { opacity:.8; font-size:14px; margin-bottom:18px; }
  #info-bar { font-size: 18px; margin-bottom: 10px; }
  #loading { font-size: 24px; margin-top: 40px; }
  #math-ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; display: none; z-index: 10; }
  #problem { font-size: 24px; margin-bottom: 10px; }
  #answer { font-size: 20px; width: 100px; text-align: center; }
  .back-link { color: #bdc3c7; text-decoration: none; margin-bottom: 10px; display: inline-block; }
  .back-link:hover { color: #ecf0f1; text-decoration: underline; }
</style>
</head>
<body>
<h1>Dungeon Crawler</h1>
<div>
    <a href="index.html" class="back-link">&larr; Back to Home</a>
</div>
<div id="info-bar">Health: <span id="health">100</span></div>
<div id="loading">Loading Assets...</div>
<div id="math-ui">
    <div id="problem"></div>
    <form id="math-form"><input type="number" id="answer" autocomplete="off" /></form>
</div>
<canvas id="gameCanvas" width="640" height="480" aria-label="Game canvas" style="display: none;"></canvas>
<script>
'use strict';
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const loadingText = document.getElementById('loading');

// UI Elements
const healthEl = document.getElementById('health');
const mathUI = document.getElementById('math-ui');
const problemEl = document.getElementById('problem');
const mathForm = document.getElementById('math-form');

// --- Game Configuration ---
const TILE_SIZE = 16;
const MAP_COLS = canvas.width / TILE_SIZE;
const MAP_ROWS = canvas.height / TILE_SIZE;

// --- Asset Loading ---
const assets = {};
const assetUrls = {
    playerIdle: 'https://placehold.co/16x16/7e22ce/FFFFFF?text=P', // Wizard
    playerRun: 'https://placehold.co/16x16/9333ea/FFFFFF?text=P',  // Wizard Running
    enemy: 'https://placehold.co/16x16/be123c/FFFFFF?text=D',      // Demon
    floor: 'https://placehold.co/16x16/374151/374151?text=.',      // Gray Floor
    wall: 'https://placehold.co/16x16/78716c/78716c?text=.'       // Stone Wall
};
let assetsLoaded = 0;
const totalAssets = Object.keys(assetUrls).length;

Object.keys(assetUrls).forEach(key => {
    assets[key] = new Image();
    assets[key].src = assetUrls[key];
    assets[key].onload = () => {
        assetsLoaded++;
        if (assetsLoaded === totalAssets) {
            loadingText.style.display = 'none';
            canvas.style.display = 'block';
            initGame();
            requestAnimationFrame(loop);
        }
    };
});

// --- Map Data (1 = wall, 0 = floor) ---
const levelMap = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1],
  [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
  [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
  [1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1],
  [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
  [1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
  [1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// --- Game State ---
let player, enemies, keys, gamePaused, currentAnswer, enemyToFight;

function initGame(){
  player = { x: TILE_SIZE * 2, y: TILE_SIZE * 2, size: TILE_SIZE, speed: 2, dx:0, dy:0, isMoving: false, animTimer: 0, health: 100, damageCooldown: 0 };
  enemies = [ { id: 0, x: TILE_SIZE * 20, y: TILE_SIZE * 5, size: TILE_SIZE, dx: 1, dy: 0, health: 1 } ];
  keys = Object.create(null);
  gamePaused = false;
}

// --- Drawing ---
function drawMap() {
    for (let row = 0; row < MAP_ROWS; row++) {
        for (let col = 0; col < MAP_COLS; col++) {
            const tile = levelMap[row] && levelMap[row][col];
            const image = tile === 1 ? assets.wall : assets.floor;
            if (image) {
                ctx.drawImage(image, col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
}

function drawPlayer() {
    let playerImage = assets.playerIdle;
    if (player.isMoving) {
        // Simple 2-frame animation
        player.animTimer++;
        playerImage = (player.animTimer % 20 < 10) ? assets.playerRun : assets.playerIdle;
    } else {
        player.animTimer = 0;
    }
    ctx.drawImage(playerImage, player.x, player.y, player.size, player.size);
}

function drawEnemies() {
    enemies.forEach(e => ctx.drawImage(assets.enemy, e.x, e.y, e.size, e.size));
}

// --- Updates ---
function isWall(x, y) {
    const col = Math.floor(x / TILE_SIZE);
    const row = Math.floor(y / TILE_SIZE);
    return levelMap[row] && levelMap[row][col] === 1;
}

function updatePlayer() {
    player.dx = (keys['ArrowRight'] || keys['KeyD'] ? 1 : 0) - (keys['ArrowLeft'] || keys['KeyA'] ? 1 : 0);
    player.dy = (keys['ArrowDown'] || keys['KeyS'] ? 1 : 0) - (keys['ArrowUp'] || keys['KeyW'] ? 1 : 0);

    player.isMoving = player.dx !== 0 || player.dy !== 0;

    if (player.damageCooldown > 0) player.damageCooldown--;

    let nextX = player.x + player.dx * player.speed;
    let nextY = player.y + player.dy * player.speed;

    // Collision detection
    if (!isWall(nextX, player.y) && !isWall(nextX + player.size - 1, player.y) &&
        !isWall(nextX, player.y + player.size - 1) && !isWall(nextX + player.size - 1, player.y + player.size - 1)) {
        player.x = nextX;
    }
    if (!isWall(player.x, nextY) && !isWall(player.x + player.size - 1, nextY) &&
        !isWall(player.x, nextY + player.size - 1) && !isWall(player.x + player.size - 1, nextY + player.size - 1)) {
        player.y = nextY;
    }
}

function updateEnemies() {
    enemies.forEach(e => {
        // Check for player collision to start battle
        if (rectsCollide(player, e)) {
            if (!gamePaused) { // Start battle only once
                startBattle(e);
            }
        }

        let nextX = e.x + e.dx;
        if (isWall(nextX, e.y) || isWall(nextX + e.size -1, e.y)) {
            e.dx *= -1;
        } else {
            e.x += e.dx;
        }

    });
    enemies = enemies.filter(e => e.health > 0);
}

function rectsCollide(a,b){ return a.x < b.x + b.size && a.x + a.size > b.x && a.y < b.y + b.size && a.y + a.size > b.y; }

// --- Battle Logic ---
function generateProblem() {
    const num1 = Math.floor(Math.random() * 10) + 1;
    const num2 = Math.floor(Math.random() * 10) + 1;
    currentAnswer = num1 + num2;
    problemEl.textContent = `${num1} + ${num2} = ?`;
}

function startBattle(enemy) {
    gamePaused = true;
    enemyToFight = enemy;
    mathUI.style.display = 'block';
    generateProblem();
    document.getElementById('answer').focus();
}

mathForm.addEventListener('submit', e => {
    e.preventDefault();
    const userAnswer = parseInt(document.getElementById('answer').value, 10);
    if (userAnswer === currentAnswer) {
        // Correct: Defeat enemy
        enemyToFight.health = 0;
    } else {
        // Incorrect: Player takes damage
        if (player.damageCooldown === 0) {
            player.health -= 10;
            healthEl.textContent = player.health;
            player.damageCooldown = 60; // 1 second invulnerability
        }
    }
    mathUI.style.display = 'none';
    document.getElementById('answer').value = '';
    gamePaused = false;
    enemyToFight = null;
    requestAnimationFrame(loop);
});

// --- Controls ---
addEventListener('keydown', e => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
    keys[e.code] = true;
});
addEventListener('keyup', e => { keys[e.code] = false;});

// --- Main Loop ---
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (player.health <= 0) {
        ctx.fillStyle = 'red';
        ctx.font = '48px sans-serif';
        ctx.fillText('GAME OVER', canvas.width/2 - 150, canvas.height/2);
        return;
    }

    drawMap();
    drawPlayer();
    drawEnemies();
    
    if (gamePaused) return;

    updatePlayer();
    updateEnemies();

    requestAnimationFrame(loop);
}

</script>
</body>
</html>