<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lasagna Quest: Blockpantry War</title>
<style>
  :root { color-scheme: dark; }
  body { background:#222; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; margin:0; text-align:center; }
  h1 { font-weight:600; margin:16px 0 6px; }
  #ui { font-size:18px; margin-bottom:10px; }
  canvas { background:#d2b48c; display:block; margin:16px auto 24px; border:2px solid #ffa500; }
  .hint { opacity:.8; font-size:14px; margin-bottom:18px; }
</style>
</head>
<body>
<h1>Lasagna Quest: Blockpantry War</h1>
<div id="ui">Health: <span id="health">100</span> | Score: <span id="score">0</span> | Inventory: <span id="inventory">None</span></div>
<div class="hint">Move: Arrow Keys or WASD. Shoot: Space. Reload page to restart.</div>
<canvas id="gameCanvas" width="800" height="600" aria-label="Game canvas"></canvas>
<script>
'use strict';
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// UI elements
const uiHealth = document.getElementById('health');
const uiScore = document.getElementById('score');
const uiInventory = document.getElementById('inventory');

// Palette
const assets = { player:'#ffa500', enemy:'#00ffff', projectile:'#ff6347', lasagna:'#ffcc00' };

// State
let player, enemies, projectiles, lasagnaItem, keys;

function initGame(){
  player = { x:100, y:100, size:40, speed:4, health:100, score:0, inventory:[], dx:0, dy:0, attackCooldown:0, damageCooldown:0 };
  enemies = [
    { x:400, y:150, size:40, dx:-1, dy:0, health:3 },
    { x:600, y:400, size:40, dx:0,  dy:1, health:3 }
  ];
  projectiles = [];
  lasagnaItem = { x:700, y:100, size:30, pickedUp:false };
  keys = Object.create(null);
  updateUI();
}

// Drawing
function drawPlayer(){ ctx.fillStyle = assets.player; ctx.fillRect(player.x, player.y, player.size, player.size); }
function drawEnemies(){
  enemies.forEach(e=>{
    ctx.fillStyle = assets.enemy; ctx.fillRect(e.x, e.y, e.size, e.size);
    // health bar
    ctx.fillStyle = '#555'; ctx.fillRect(e.x, e.y-10, e.size, 5);
    ctx.fillStyle = '#0ff'; ctx.fillRect(e.x, e.y-10, (Math.max(e.health,0)/3)*e.size, 5);
  });
}
function drawLasagna(){ if(!lasagnaItem.pickedUp){ ctx.fillStyle = assets.lasagna; ctx.fillRect(lasagnaItem.x, lasagnaItem.y, lasagnaItem.size, lasagnaItem.size);} }
function drawProjectiles(){
  ctx.fillStyle = assets.projectile;
  projectiles.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.fill(); });
}

// Updates
function updateEnemies(){
  enemies.forEach(e=>{
    e.x += e.dx; e.y += e.dy;
    // bounce
    if(e.x<0 || e.x+e.size>canvas.width) e.dx*=-1;
    if(e.y<0 || e.y+e.size>canvas.height) e.dy*=-1;
    // chase if within 200px
    const dx = player.x - e.x, dy = player.y - e.y; const dist = Math.hypot(dx,dy);
    if(dist>0 && dist<200){ e.dx = (dx/dist)*1.5; e.dy = (dy/dist)*1.5; }
  });
}
function updatePlayer(){
  // aggregate keys
  player.dx = (keys['ArrowRight']||keys['KeyD']?1:0) - (keys['ArrowLeft']||keys['KeyA']?1:0);
  player.dy = (keys['ArrowDown']||keys['KeyS']?1:0) - (keys['ArrowUp']||keys['KeyW']?1:0);
  const inv = 1/Math.max(1, Math.hypot(player.dx, player.dy));
  player.x += player.dx*player.speed*inv; player.y += player.dy*player.speed*inv;
  // clamp to canvas
  player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
  player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));
  if(player.attackCooldown>0) player.attackCooldown--;
  if(player.damageCooldown>0) player.damageCooldown--;
}
function updateProjectiles(){
  projectiles.forEach(p=>{ p.x += p.dx; p.y += p.dy; });
  // cull offscreen or flagged
  projectiles = projectiles.filter(p=> !p.toRemove && p.x>-10 && p.x<canvas.width+10 && p.y>-10 && p.y<canvas.height+10);
  // collisions with enemies
  projectiles.forEach(p=>{
    enemies.forEach(e=>{ if(rectCircleColliding(e,p)){ e.health--; p.toRemove=true; } });
  });
  enemies = enemies.filter(e=> e.health>0);
}

// Collisions
function rectsCollide(a,b){ return a.x < b.x + b.size && a.x + a.size > b.x && a.y < b.y + b.size && a.y + a.size > b.y; }
function rectCircleColliding(rect, circle){
  const distX = Math.abs(circle.x - rect.x - rect.size/2);
  const distY = Math.abs(circle.y - rect.y - rect.size/2);
  if (distX > rect.size/2 + circle.radius || distY > rect.size/2 + circle.radius) return false;
  if (distX <= rect.size/2 || distY <= rect.size/2) return true;
  const dx = distX - rect.size/2; const dy = distY - rect.size/2;
  return dx*dx + dy*dy <= circle.radius*circle.radius;
}

// Rules
function checkLasagnaPickup(){
  if(!lasagnaItem.pickedUp && rectsCollide(player, lasagnaItem)){
    lasagnaItem.pickedUp = true; player.inventory.push('Lasagna'); player.score += 10; updateUI();
  }
}
function checkEnemyAttack(){
  if(player.damageCooldown>0) return;
  for(const e of enemies){ if(rectsCollide(player,e)){ player.health -= 1; player.damageCooldown = 30; updateUI(); if(player.health<=0){ alert('Game Over!'); initGame(); } break; } }
}

// UI
function updateUI(){ uiHealth.textContent = player.health; uiScore.textContent = player.score; uiInventory.textContent = player.inventory.length? player.inventory.join(', '): 'None'; }

// Controls
addEventListener('keydown', e=>{
  // prevent page scroll on arrows/space
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  keys[e.code] = true;
  if(e.code==='Space' && player.attackCooldown===0){
    // shoot to the right; could be extended to aim
    projectiles.push({ x: player.x + player.size/2, y: player.y + player.size/2, dx: 6, dy: 0, radius: 6 });
    player.attackCooldown = 20;
  }
});
addEventListener('keyup', e=>{ keys[e.code] = false; });

// Main loop
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawLasagna();
  drawPlayer();
  drawEnemies();
  drawProjectiles();
  updatePlayer();
  updateEnemies();
  updateProjectiles();
  checkLasagnaPickup();
  checkEnemyAttack();
  requestAnimationFrame(loop);
}

initGame();
requestAnimationFrame(loop);
</script>
</body>
</html>